---
title: "Low Transmission of the SARS-CoV-2 XFG Variant in Coastal Kenya"
author: "Ziquan 'Harrison' Liu"
format:
  html:
    code-fold: true
---

```{r setup, include=FALSE}
# 这一整个 chunk 用来做全局设置和加载 R 包
# include=FALSE 表示这块的代码和结果都不会直接显示在网页上

# 设置 knitr 的 chunk 默认选项：显示代码、但隐藏 warning/message
knitr::opts_chunk$set(
  echo = TRUE,      # 默认显示代码
  warning = FALSE,  # 不显示警告
  message = FALSE   # 不显示加载包等信息
)
```

```{r}
# requried packages:
# Load required packages

# 这一整个 chunk 专门用来加载本项目需要的 R 包

# 每一行都是在加载一个 R 包，这些包分别用于数据清洗、作图、表格和交互式图形

library(quarto)
library(tidyverse)  # 数据清洗和可视化（ggplot2 在 tidyverse 里）
library(lubridate)  # 处理日期变量，比如把字符转成 Date
library(janitor)    # 干净变量名和简单的频数表
library(arsenal)    # tableby()，用来生成 publication-ready 的描述性表格
library(kableExtra) # 把表格美化成论文风格式
library(plotly)     # 把 ggplot 图转成交互式图形
library(gt)         # 另一种漂亮表格（可选，用在结果部分）
```

```{r}
# Read Packages
# ---- Load and prepare analysis dataset ----

# 这一整个 chunk 负责：读取原始 csv 数据、做最基本的清洗和派生变量

# 注意：这里假设 Data1_xfg.csv 保存在项目文件夹下的 data/ 子文件夹中

# 1. 读取数据文件

Data_xfg_raw <- readr::read_csv(
file = "/Users/ldh/Library/Mobile Documents/com~apple~CloudDocs/USC PhD/STUDY DOCUMENTS/Fall 2025/PM 566/Final Project/Potential dataset/ALambisia_SARS_COV_2_XFG_Data/Data1_xfg.csv"  # 指定相对路径，方便在不同电脑上使用
)

# 2. 使用 clean_names() 统一变量名风格（全小写+下划线），更好写代码

Data_xfg <- Data_xfg_raw %>%
janitor::clean_names()

# 3. 把 date_collect 从字符转换成 Date 类型（原格式为日/月/年）

Data_xfg <- Data_xfg %>%
mutate(
date_collect = lubridate::dmy(date_collect)  # dmy() = day-month-year
)

# 4. 创建一个简化的 lineage 变量：XFG vs non-XFG

Data_xfg <- Data_xfg %>%
mutate(
# nextclade_pango2 是原始的 lineage 变量
lineage_group = if_else(
stringr::str_starts(nextclade_pango2, "XFG"),  # 如果以 XFG 开头
"XFG lineage",                                 # 标记为 XFG
"Other lineages"                              # 否则标记为其他谱系
),
lineage_group = factor(
lineage_group,
levels = c("XFG lineage", "Other lineages")   # 设定因子顺序，方便后续画图
)
)

# 5. 把 clinical_status 标准化为 factor，保证水平顺序合理

Data_xfg <- Data_xfg %>%
mutate(
clinical_status = factor(
clinical_status,
levels = c("asymptomatic", "symptomatic")
)
)

# 6. 检查 study 变量的水平，用来在图和表里排序

Data_xfg <- Data_xfg %>%
mutate(
study = factor(
study,
levels = c("HF", "pricos", "ResViRe")  # 手动设置顺序，跟原文一致
)
)

```

# Introduction
The SARS-CoV-2 recombinant lineage XFG emerged as a globally dominant variant in 2025. However, its local transmission dynamics can vary between settings. In this project, we use publicly available replication data from Lambisia et al. (2025) to explore demographic, clinical, and virologic characteristics of XFG infections detected through three surveillance studies in coastal Kenya (HF, pricos, and ResViRe).

Our goal is to describe patterns in Ct values, symptoms, and viral lineages across study groups and to visualise how frequently XFG was detected, rather than to draw causal conclusions.

# Mothods
## Data and Study Population:
sample size...data source...
## Statistical analysis
```{r}
# ---- Descriptive baseline table (Table 1) ----

# 这一整个 chunk 用 arsenal::tableby() 生成类似论文 Table 1 的基线特征表，

# 按 study 分层，总结性别、年龄、Ct 值、lineage、临床状态和症状情况。

# 1. 指定需要进入 Table 1 的变量列表

vars_for_table1 <- c(
"sex", "age_years", "age_group", "ct_value",
"nextclade_pango2", "clinical_status",
"sys_cough", "sys_headache", "sys_runny_nose",
"sys_sore_throat", "sys_chestpain", "sys_fever"
)

# 2. 用 tableby() 根据 study 分组做描述性统计

tab1 <- arsenal::tableby(
formula = as.formula(
paste("study ~", paste(vars_for_table1, collapse = " + "))
),                     # 构造公式 study ~ var1 + var2 + ...
data = Data_xfg,       # 使用我们刚清洗好的 Data_xfg 数据集
control = tableby.control(
numeric.stats = c("medianq1q3", "N"),      # 数值型变量用 中位数(IQR) 和 N
stats.labels = list(medianq1q3 = "Median (IQR)")
)
)

# 3. 把 tableby 的结果转成 kableExtra 表格，方便在网页中展示

tab1_kable <- summary(tab1, text = FALSE) %>%   # text=FALSE 返回 data.frame 格式
as.data.frame() %>%
kbl(
format = "html",         # 输出 html 表格
caption = "Table 1. Participant characteristics by study.",
escape = FALSE,          # 允许 HTML，例如 <br> 保留格式
booktabs = TRUE
) %>%
kableExtra::kable_styling(
full_width = FALSE,      # 不让表格占满整行
bootstrap_options = c("striped", "hover", "condensed")
) %>%
kableExtra::scroll_box(
height = "500px"         # 给表格一个滚动框，避免太长
)

tab1_kable   # 打印表格到 report 中

```

## Visualisation strategy
We utilized ggplot + plotly, at least one interactive graphic. The specific result referring to results section.

# Results
## Lineage distribution across studies (Interactive)
```{r}
# ---- Interactive bar chart: lineage distribution by study ----

# 这个 chunk 先用 ggplot 画分组柱状图，然后用 ggplotly() 转成可交互的图。

# 目的：展示在三个 study 中 XFG vs Other lineages 的数量和比例。

# 1. 计算每个 study 内 XFG vs 其他谱系的频数和比例

lineage_summary <- Data_xfg %>%
count(study, lineage_group) %>%         # 计算每个组合的计数
group_by(study) %>%                     # 按 study 分组
mutate(
prop = n / sum(n) * 100               # 计算百分比
) %>%
ungroup()

# 2. 使用 ggplot 画分组柱状图（y 轴为百分比）

p_lineage <- ggplot(lineage_summary,
aes(x = study,
y = prop,
fill = lineage_group,
text = paste0(
"Study: ", study, "<br>",
"Lineage: ", lineage_group, "<br>",
"N: ", n, "<br>",
"Proportion: ", round(prop, 1), "%")
)) +
geom_col(position = "stack") +          # 堆叠柱状图，显示比例
scale_y_continuous(labels = scales::percent_format(scale = 1)) +
labs(
title = "Distribution of XFG and other lineages by study",
x = "Study",
y = "Proportion of samples (%)",
fill = "Lineage group"
) +
theme_minimal()

# 3. 用 plotly::ggplotly() 把 ggplot 转成可交互的 html 图

plotly::ggplotly(p_lineage, tooltip = "text")

```
Among HF/pricos/ResViRe, XFG occupied how many percentages? to emphasize the low transmission.

## Ct values by clinical status and lineage
```{r}
# ---- Ct value distribution by clinical status and lineage ----
# 这个 chunk 画一个按临床状态分组、按 lineage 着色的散点 + 箱线图，
# 帮助我们比较 symptomatic vs asymptomatic 在 Ct 值上的差异，
# 同时避免样本量只有 1 个的组里出现“奇怪的一条横线”的 boxplot。

# 1. 先过滤掉缺失的 Ct 值，并在每个分组里算出样本量 n --------------------
ct_data <- Data_xfg %>%                             # 使用主数据集 Data_xfg
  dplyr::filter(!is.na(ct_value)) %>%              # 去掉 Ct 缺失的记录
  dplyr::group_by(clinical_status, lineage_group) %>%  # 以临床状态 + lineage 分组
  dplyr::mutate(
    n_in_group = dplyr::n()                        # 给每一行加上所在组的样本量 n
  ) %>%
  dplyr::ungroup()                                # 取消分组，方便后面作图

# 2. 画图：只对 n >= 2 的组画 boxplot，所有点都画出来 -----------------------
p_ct <- ggplot(
  ct_data,
  aes(
    x = clinical_status,                           # x 轴：无症状 / 有症状
    y = ct_value,                                  # y 轴：Ct 值
    color = lineage_group                          # 颜色：lineage 分组
  )
) +
  # 2.1 只在样本量 ≥ 2 的组画箱线图，避免 n=1 变成一条奇怪的横线
  geom_boxplot(
    data = ct_data %>% dplyr::filter(n_in_group >= 2),  # 只保留 n>=2 的组画箱线
    alpha = 0.4,                                  # 箱子半透明一点
    outlier.shape = NA                            # 不额外画箱线自带的 outlier 点
  ) +
  # 2.2 所有观测都用散点展示（包括样本只有 1 个的组）
  geom_jitter(
    width = 0.1,                                  # 水平方向轻微抖动，避免完全重叠
    size = 2                                      # 点的大小
  ) +
  # 2.3 y 轴反转：Ct 越低（病毒量越高）越靠上
  scale_y_reverse() +
  # 2.4 图的标题和坐标轴标签
  labs(
    title  = "Ct values by clinical status and lineage",
    x      = "Clinical status",
    y      = "Ct value (lower = higher viral load)",
    color  = "Lineage group"
  ) +
  # 2.5 使用简洁的主题
  theme_minimal()

# 3. 打印图形 -------------------------------------------------------
p_ct

```
Ct distrubution, if symptomatic had lower Ct (higher viral load) trend; contrast between XFG vs non-XFG, pay attention the sample size, emphasize "suggestive pattern only"

## Simple regression: association between Ct and symptoms
```{r}
# ---- Create binary outcome: symptomatic vs asymptomatic ----
# We first create a simple 0/1 variable for symptoms.
# 1 = symptomatic, 0 = asymptomatic.
# This avoids having a long expression like (clinical_status == "symptomatic")
# inside the model formula, which previously created ugly term names
# and broke the labeling code.

Data_xfg <- Data_xfg %>%                   # start from main analysis dataset
  dplyr::mutate(
    symptomatic = dplyr::if_else(          # create new binary outcome
      clinical_status == "symptomatic",    # condition: symptomatic vs asymptomatic
      1L,                                  # code 1 for symptomatic
      0L,                                  # code 0 for asymptomatic
      missing = NA_integer_                # keep NA as NA (if any)
    )
  )

# ---- Fit simple logistic regression model ----
# Outcome: symptomatic (1/0)
# Predictors: Ct value (continuous), lineage group, age in years.
# This is purely exploratory and *not* the main focus of the project.
# The main project goal remains descriptive, but this model can be a bonus.

symp_model <- glm(
  symptomatic ~ ct_value + lineage_group + age_years,  # model formula
  data   = Data_xfg %>%
    dplyr::filter(                                     # keep only complete cases
      !is.na(symptomatic),
      !is.na(ct_value),
      !is.na(age_years),
      !is.na(lineage_group)
    ),
  family = binomial()                                  # logistic regression
)

# ---- Tidy model output and make a clean, readable table ----
# We exponentiate the coefficients to get odds ratios (OR),
# and then add 95% confidence intervals and p-values.

symp_results <- broom::tidy(
  symp_model,
  conf.int    = TRUE,    # add confidence intervals
  exponentiate = TRUE    # report OR instead of log-odds
) %>%
  dplyr::mutate(
    # Relabel the term column to something human-readable.
    # Note: we now have clean term names: "(Intercept)", "ct_value",
    # "lineage_groupOther lineages", "age_years".
    term = dplyr::case_when(
      term == "(Intercept)" ~
        "Intercept (baseline: XFG lineage, younger age)",
      term == "ct_value" ~
        "Ct value (per 1 unit higher)",
      term == "lineage_groupOther lineages" ~
        "Other vs XFG lineages",
      term == "age_years" ~
        "Age (per 1 year older)",
      TRUE ~ term                                   # default: keep original
    ),
    # Round numbers for a clean table
    estimate  = round(estimate, 2),                 # odds ratio
    conf.low  = round(conf.low, 2),                 # lower 95% CI
    conf.high = round(conf.high, 2),                # upper 95% CI
    p.value   = signif(p.value, 2)                  # p-value with 2 sig digits
  ) %>%
  dplyr::select(
    Term              = term,                       # rename columns for display
    `Odds ratio`      = estimate,
    `95% CI (lower)`  = conf.low,
    `95% CI (upper)`  = conf.high,
    `p-value`         = p.value
  )

# ---- Print the table in a stable, low-bug way ----
# Here we use knitr::kable instead of gt. kable is simpler and tends to fail less
# on Quarto/GitHub Pages. If you later want a fancier style, you can wrap
# kableExtra::kable_styling around it.

knitr::kable(
  symp_results,
  caption = "Association between Ct value, viral lineage and symptomatic infection (logistic regression)"
)


```
the esitmate of OR, and emphasize the limitation of sample size and wider 95%CI

## Symptom profiles across studies
```{r symptom-profiles, message=FALSE, warning=FALSE}
# ---- Symptom profiles across studies ----
# This code chunk creates a descriptive bar plot showing,
# for each participating study (HF, pricos, ResViRe),
# the proportion of participants reporting each symptom
# (cough, headache, runny nose, sore throat, chest pain, fever).
# It is purely descriptive and helps compare symptom patterns
# across studies for a general audience.

# 1. Reshape symptom variables into a long format ----------------------

symptom_long <- Data_xfg %>%                                   # start from main dataset
  dplyr::select(                                               # keep only study + symptom variables
    study,
    sys_cough, sys_headache, sys_runny_nose,
    sys_sore_throat, sys_chestpain, sys_fever
  ) %>%
  tidyr::pivot_longer(                                         # convert wide symptom columns to long format
    cols = starts_with("sys_"),                                # all variables whose names start with "sys_"
    names_to  = "symptom",                                     # new column that stores symptom name
    values_to = "symptom_present"                              # new column that stores Yes/No response
  ) %>%
  dplyr::mutate(
    # Give each symptom a short, readable label for plotting
    symptom = dplyr::recode(
      symptom,
      "sys_cough"        = "Cough",
      "sys_headache"     = "Headache",
      "sys_runny_nose"   = "Runny nose",
      "sys_sore_throat"  = "Sore throat",
      "sys_chestpain"    = "Chest pain",
      "sys_fever"        = "Fever"
    ),
    # Recode Yes/No into 1/0 so we can compute proportions easily
    symptom_present = dplyr::if_else(
      symptom_present == "Yes",                                # if the original value is "Yes"
      1L,                                                      # code as 1 (symptom present)
      dplyr::if_else(
        symptom_present == "No",                               # if the original value is "No"
        0L,                                                    # code as 0 (symptom absent)
        NA_integer_                                           # otherwise keep as missing
      )
    )
  )

# 2. Calculate the proportion with each symptom within each study -----

symptom_summary <- symptom_long %>%
  dplyr::filter(!is.na(symptom_present)) %>%                   # drop rows with missing Yes/No
  dplyr::group_by(study, symptom) %>%                          # group by study and symptom type
  dplyr::summarise(
    n          = dplyr::n(),                                   # total number of participants in this group
    n_symptom  = sum(symptom_present),                         # count with symptom present (value == 1)
    prop_symptom = n_symptom / n                              # proportion with the symptom
  ) %>%
  dplyr::ungroup()                                             # remove grouping to avoid side effects later

# 3. Make a faceted bar plot of symptom proportions by study ----------

p_symptom_study <- ggplot(
  symptom_summary,                                             # use summary data frame for plotting
  aes(
    x = study,                                                 # x-axis: study (HF, pricos, ResViRe)
    y = prop_symptom                                           # y-axis: proportion with the symptom
  )
) +
  geom_col(                                                    # draw solid bars (columns)
    fill  = "#1B9E77",                                         # choose a single calm color for all bars
    alpha = 0.8                                                # slightly transparent for a softer look
  ) +
  scale_y_continuous(                                          # format y-axis as percentages
    labels = scales::percent_format(accuracy = 1)              # show values like 40%
  ) +
  labs(
    title   = "Symptom profiles across participating studies", # main title
    x       = "Study",                                         # x-axis label
    y       = "Participants with symptom",                     # y-axis label
    caption = "Each bar shows the proportion of participants within each study reporting the symptom.\nSample sizes are small, so percentages should be interpreted with caution."
  ) +
  facet_wrap(~ symptom, nrow = 2) +                            # create small panels for each symptom
  theme_minimal() +                                            # clean, minimal theme
  theme(
    plot.title = element_text(face = "bold", size = 14),       # emphasize plot title
    strip.text = element_text(face = "bold"),                  # bold facet labels (symptom names)
    axis.text.x = element_text(angle = 0, hjust = 0.5)         # keep study labels horizontal for readability
  )

p_symptom_study                                                 # print the plot to the report
```

# Conclusion and Summary
the different age distribusion among project; XFG frequency was relatively low in the 21 samples; though a slight trend between Ct and symptom but the sample is too small to provide reliable evidence; 


