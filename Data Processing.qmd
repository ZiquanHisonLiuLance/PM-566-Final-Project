---
title: "Data Processing"
author: "Ziquan 'Harrison' Liu"
format:
  html:
    code-fold: true
---
- Repository: Harvard Dataverse  
- Dataset title: *Replication Data for: Low Transmission of the Globally Dominant Recombinant SARS-CoV-2 XFG variant in Kenya, May–July 2025*  
- DOI: https://doi.org/10.7910/DVN/LJEYL6  
- Year: 2025  

The replication data package comprises a primary analytic dataset (`Data1_xfg.csv`), a codebook describing the variables, and an R Markdown script used to reproduce Table 1 in the original manuscript. For this project, I downloaded the full package and stored `Data1_xfg.csv` in the local `data/` directory of this RStudio project (this file is not published to GitHub to respect data-sharing boundaries).

The dataset contains 21 RT-PCR–confirmed SARS-CoV-2 infections collected between May and July 2025 from three surveillance platforms in coastal Kenya. Each row represents one participant or sample.

```{r load-data-processing, message=FALSE, warning=FALSE}
# Load raw data and perform initial cleaning
# This chunk reads the raw CSV file, cleans variable names,
# and creates derived variables needed for later analysis.

library(tidyverse)  # data wrangling and visualization
library(lubridate)  # date handling
library(janitor)    # clean variable names

# Read the dataset from the local data/ folder (relative path)
Data_xfg_raw <- readr::read_csv("data/Data1_xfg.csv")

# Clean variable names and derive factors used later in the report
Data_xfg <- Data_xfg_raw %>%
  janitor::clean_names() %>%
  mutate(
    # Convert collection date from character (day-month-year) to Date
    date_collect = lubridate::dmy(date_collect),

    # Collapse detailed Pango lineages into a two-level factor:
    # XFG vs all other lineages
    lineage_group = if_else(
      stringr::str_starts(nextclade_pango2, "XFG"),
      "XFG lineage",
      "Other lineages"
    ),
    lineage_group = factor(lineage_group),

    # Make clinical status an ordered factor (asymptomatic -> symptomatic)
    clinical_status = factor(
      clinical_status,
      levels = c("asymptomatic", "symptomatic")
    ),

    # Ensure study labels appear in a consistent order
    study = factor(
      study,
      levels = c("HF", "pricos", "ResViRe")
    )
  )
```
Following the cleaning process, no observations were discarded; all 21 samples were preserved. The variable date_collect was transformed into a Date class with lubridate::dmy(). The lineage variable nextclade_pango2 was reclassified into a more straightforward two-level factor lineage_group (“XFG lineage” vs “Other lineages”). The variables study, clinical_status, and age_group were specifically designated as factors to guarantee uniform ordering in tables and figures. No imputation was conducted.

# Descriptive tables
```{r tbl-study-lineage, message=FALSE, warning=FALSE}
# This chunk creates a simple descriptive table showing how many samples belong to each combination of study and lineage_group.
study_lineage_tab <- Data_xfg %>%
  dplyr::count(study, lineage_group) %>%
  dplyr::group_by(study) %>%
  dplyr::mutate(
    prop = n / sum(n) * 100   # percentage within each study
  ) %>%
  dplyr::ungroup()

study_lineage_tab %>%
  dplyr::mutate(
    prop = round(prop, 1)
  ) %>%
  knitr::kable(
    caption = "Table A. Distribution of XFG vs other lineages by study",
    col.names = c("Study", "Lineage group", "N", "Percent within study")
  )
```
The table summarized the number of sequenced infections attributed to the XFG lineage compared to other SARS-CoV-2 lineages across each surveillance platform. Percentages indicated that, in each investigation, XFG constitutes merely a minority of identified infections, aligning with restricted local proliferation.
```{r tbl-study-status, message=FALSE, warning=FALSE}
# This chunk creates a table for clinical status (symptomatic vs asymptomatic) across the three surveillance platforms.

study_status_tab <- Data_xfg %>%
  dplyr::count(study, clinical_status) %>%
  dplyr::group_by(study) %>%
  dplyr::mutate(
    prop = n / sum(n) * 100
  ) %>%
  dplyr::ungroup()

study_status_tab %>%
  dplyr::mutate(
    prop = round(prop, 1)
  ) %>%
  knitr::kable(
    caption = "Table B. Clinical status (symptomatic vs asymptomatic) by study",
    col.names = c("Study", "Clinical status", "N", "Percent within study")
  )
```
Additionally, This table illustrated the frequency of symptomatic compared to asymptomatic infections detected across each surveillance platform. Due to the limited number of participants in each group, these proportions should be regarded as descriptive summaries rather than exact estimations.

# Exploratory plots
This section's charts aim to illustrate the age distribution of participants and the general prevalence of reported symptoms. Due to the limited sample size, these graphs should be interpreted as descriptive representations rather than accurate estimations.

## Age distribution  
```{r}
# This chunk visualizes the distribution of participant ages (in years).
# A simple histogram is used due to the small sample size.

ggplot(Data_xfg, aes(x = age_years)) +
geom_histogram(
bins = 8, # a small number of bins given N = 21
fill = "#2E86AB",
alpha = 0.8,
color = "white"
) +
labs(
title = "Age distribution of SARS-CoV-2 positive participants",
x = "Age (years)",
y = "Count"
) +
theme_minimal()

# Expected result: a histogram showing how the 21 participants are distributed across age, highlighting the mix of children, adolescents, and adults.
```
This histogram provided a concise representation of the age distribution among the 21 participants who tested positive for SARS-CoV-2. The values on the y-axis represented the number of individuals within each age category. The chart demonstrated that the sample comprises a diverse range of children, adolescents, and adults, with no single age group significantly prevailing in the dataset. 

## Sample size by study
```{r study-sample-size}
# This chunk summarized how many observations were contributed by each study.
# It gave context for later stratified analyses.

study_counts <- Data_xfg %>%
dplyr::count(study) # count number of rows per study

ggplot(study_counts, aes(x = study, y = n)) +
geom_col(
fill = "#6C5B7B",
alpha = 0.85
) +
labs(
title = "Number of samples by study",
x = "Study",
y = "Sample size (N)"
) +
theme_minimal()

# Expected result:A bar chart showing how many participants were included from each study,indicating the relative contribution of HF, pricos, and ResViRe.
```
This bar chart delineated the number of observations contributed by each of the three surveillance platforms: HF, pricos, and ResViRe.  The height of each bar indicates the quantity of sequenced infections in the dataset originating from that study. The figure indicates that sample sizes are modest across all platforms and not perfectly balanced, elucidating why certain stratified analyses in the main report remain descriptive and should not be subjected to excessive statistical interpretation.

## Number of reported symptoms per participant
```{r}
# This chunk counts, for each participant, how many different symptoms were reported, and then displays the distribution of this count.

# 1. List the symptom variables to be considered.
symptom_vars <- c(
"sys_cough", "sys_headache", "sys_runny_nose",
"sys_sore_throat", "sys_chestpain", "sys_fever"
)

# 2. For each participant, count the number of symptoms with value "Yes".
symptom_counts <- Data_xfg %>%
mutate(
n_symptoms = rowSums(
across(
all_of(symptom_vars),
~ .x == "Yes" # TRUE when the symptom is present
),
na.rm = TRUE # treat missing as 0 in the sum
)
)

# 3. Plot the distribution of the count of reported symptoms.
ggplot(symptom_counts, aes(x = n_symptoms)) +
geom_bar(
fill = "#F39C12",
alpha = 0.8
) +
labs(
title = "Number of reported symptoms per participant",
x = "Number of symptoms",
y = "Count"
) +
theme_minimal()

# Expected result: a bar chart showing how many participants reported 0, 1, 2, etc symptoms. This helps describe overall symptom burden in the small cohort.
```
This graphic displayed the distribution of symptoms reported by each participant.  The x-axis represented the number of unique symptoms endorsed by an individual (ranging from zero to the maximum observed), while the y-axis indicates the number of participants within each category. The majority of participants showed experiencing one to four symptoms, with a limited number of persons reporting either no symptoms or a significantly high number of symptoms. This distribution provided a succinct overview of the total symptom burden within the limited cohort.

## Overall Ct value distribution
```{r ct-distribution}
# This chunk visualizes the overall distribution of Ct values across all sequenced samples in the dataset.

ct_nonmiss <- Data_xfg %>%
dplyr::filter(!is.na(ct_value)) # keep only records with observed Ct

ggplot(ct_nonmiss, aes(x = ct_value)) +
geom_histogram(
bins = 8,
fill = "#3498DB",
alpha = 0.8,
color = "white"
) +
scale_x_reverse() + # lower Ct (higher viral load) on the right
labs(
title = "Distribution of Ct values among sequenced infections",
x = "Ct value (lower = higher viral load)",
y = "Count"
) +
theme_minimal()

# Expected result: A histogram summarizing Ct values across all 21 samples, offering a quick overview of viral load levels before stratified analyses.
```
This histogram summrized the distribution of Ct values among all sequenced illnesses with available measurements. The x-axis is represented on a reversed scale, such that lower Ct values, indicative of higher viral load, are positioned on the right. The distribution's structure indicates that the majority of infections concentrate around moderate Ct levels, with a limited number of exceptionally low or high values. The picture is chiefly beneficial for illustrating the spectrum of viral loads depicted in the dataset.

## Symptom co-occurrence heatmap
```{r symptom-cooccurrence, message=FALSE, warning=FALSE}
# This chunk explores how often pairs of symptoms are reported together.
# It creates a heatmap where darker cells mean that the two symptoms co-occur more frequently among the 21 participants.

# 1. Define symptom variables and create a 0/1 matrix
symptom_vars <- c(
  "sys_cough", "sys_headache", "sys_runny_nose",
  "sys_sore_throat", "sys_chestpain", "sys_fever"
)

symptom_matrix <- Data_xfg %>%
  dplyr::select(dplyr::all_of(symptom_vars)) %>%
  dplyr::mutate(
    dplyr::across(
      dplyr::everything(),
      ~ dplyr::case_when(
        .x == "Yes" ~ 1L,
        .x == "No"  ~ 0L,
        TRUE        ~ NA_integer_
      )
    )
  ) %>%
  as.matrix()

# 2. Compute co-occurrence counts: how many participants have each pair of symptoms
co_count <- t(symptom_matrix) %*% symptom_matrix

# 3. Convert to long format for plotting
symptom_names <- c(
  "sys_cough"       = "Cough",
  "sys_headache"    = "Headache",
  "sys_runny_nose"  = "Runny nose",
  "sys_sore_throat" = "Sore throat",
  "sys_chestpain"   = "Chest pain",
  "sys_fever"       = "Fever"
)

co_df <- as.data.frame(as.table(co_count)) %>%
  dplyr::rename(
    symptom1 = Var1,
    symptom2 = Var2,
    n_both   = Freq
  ) %>%
  dplyr::mutate(
    symptom1_lab = symptom_names[symptom1],
    symptom2_lab = symptom_names[symptom2]
  )

# 4. Plot heatmap of co-occurrence counts
ggplot(
  co_df,
  aes(x = symptom1_lab, y = symptom2_lab, fill = n_both)
) +
  geom_tile(color = "white") +
  scale_fill_gradient(
    low  = "#eff3ff",
    high = "#2171b5",
    name = "N with both\nsymptoms"
  ) +
  labs(
    title = "Co-occurrence of reported symptoms",
    x     = "Symptom 1",
    y     = "Symptom 2"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title  = element_text(face = "bold")
  )
```
This heatmap showed the frequency of individuals reporting both symptoms for each symptom pair. Darker cells signify symptom pairs that frequently co-occur (e.g., cough and sore throat), while lighter cells represent combinations that were infrequently co-reported. The limited sample size renders the pattern primarily beneficial for qualitative depiction rather than for formal inference.

## Ct value distribution by study
```{r ct-by-study, message=FALSE, warning=FALSE}
# This chunk compares the distribution of Ct values across the three studies.
# It uses a combination of violin plots, boxplots, and jittered points.

ct_nonmiss <- Data_xfg %>%
  dplyr::filter(!is.na(ct_value))

ggplot(
  ct_nonmiss,
  aes(
    x     = study,
    y     = ct_value,
    fill  = study
  )
) +
  geom_violin(
    alpha  = 0.5,
    trim   = TRUE
  ) +
  geom_boxplot(
    width  = 0.2,
    alpha  = 0.7,
    outlier.shape = NA
  ) +
  geom_jitter(
    width  = 0.05,
    size   = 2,
    alpha  = 0.9
  ) +
  scale_y_reverse() +
  labs(
    title = "Ct value distribution across surveillance platforms",
    x     = "Study",
    y     = "Ct value (lower = higher viral load)",
    fill  = "Study"
  ) +
  theme_minimal()
```
These violin plots provided a concise visual representation of the variation in Ct values among the three monitoring systems. The integration of violins, boxplots, and individual data points emphasizes both the general distribution and the fundamental raw data. Overall, Ct distributions exhibit a notable similarity among HF, pricos, and ResViRe, with no distinct study demonstrating consistently elevated or diminished viral loads.