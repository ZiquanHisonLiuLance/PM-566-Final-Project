## 1 = symptomatic, 0 = asymptomatic.
## This avoids having a long expression like (clinical_status == "symptomatic") inside the model formula, which previously created ugly term names and broke the labeling code.
Data_xfg <- Data_xfg %>%                   # start from main analysis dataset
dplyr::mutate(
symptomatic = dplyr::if_else(          # create new binary outcome
clinical_status == "symptomatic",    # condition: symptomatic vs asymptomatic
1L,                                  # code 1 for symptomatic
0L,                                  # code 0 for asymptomatic
missing = NA_integer_                # keep NA as NA (if any)
)
)
# Fit simple logistic regression model
# Outcome: symptomatic (1/0)
# Predictors: Ct value (continuous), lineage group, age in years.
# This is purely exploratory and *not* the main focus of the project.
# The main project goal remains descriptive, but this model can be a bonus.
symp_model <- glm(
symptomatic ~ ct_value + lineage_group + age_years,  # model formula
data   = Data_xfg %>%
dplyr::filter(                                     # keep only complete cases
!is.na(symptomatic),
!is.na(ct_value),
!is.na(age_years),
!is.na(lineage_group)
),
family = binomial()                                  # logistic regression
)
# Tidy model output and make a clean, readable table
# We exponentiate the coefficients to get odds ratios (OR),
# and then add 95% confidence intervals and p-values.
symp_results <- broom::tidy(
symp_model,
conf.int    = TRUE,    # add confidence intervals
exponentiate = TRUE    # report OR instead of log-odds
) %>%
dplyr::mutate(
# Relabel the term column to something human-readable.
# Note: we now have clean term names: "(Intercept)", "ct_value",
# "lineage_groupOther lineages", "age_years".
term = dplyr::case_when(
term == "(Intercept)" ~
"Intercept (baseline: XFG lineage, younger age)",
term == "ct_value" ~
"Ct value (per 1 unit higher)",
term == "lineage_groupOther lineages" ~
"Other vs XFG lineages",
term == "age_years" ~
"Age (per 1 year older)",
TRUE ~ term                                   # default: keep original
),
# Round numbers for a clean table
estimate  = round(estimate, 2),                 # odds ratio
conf.low  = round(conf.low, 2),                 # lower 95% CI
conf.high = round(conf.high, 2),                # upper 95% CI
p.value   = signif(p.value, 2)                  # p-value with 2 sig digits
) %>%
dplyr::select(
Term              = term,                       # rename columns for display
`Odds ratio`      = estimate,
`95% CI (lower)`  = conf.low,
`95% CI (upper)`  = conf.high,
`p-value`         = p.value
)
# Print the table in a stable, low-bug way
# Here we use knitr::kable instead of gt. kable is simpler and tends to fail less
# on Quarto/GitHub Pages. If you later want a fancier style, you can wrap
# kableExtra::kable_styling around it.
knitr::kable(
symp_results,
caption = "Association between Ct value, viral lineage and symptomatic infection (logistic regression)"
)
# This code chunk creates a descriptive bar plot showing, for each participating study (HF, pricos, ResViRe), the proportion of participants reporting each symptom
# (cough, headache, runny nose, sore throat, chest pain, fever).
# It is purely descriptive and helps compare symptom patterns across studies for a general audience.
# 1. Reshape symptom variables into a long format
symptom_long <- Data_xfg %>%                                   # start from main dataset
dplyr::select(                                               # keep only study + symptom variables
study,
sys_cough, sys_headache, sys_runny_nose,
sys_sore_throat, sys_chestpain, sys_fever
) %>%
tidyr::pivot_longer(                                         # convert wide symptom columns to long format
cols = starts_with("sys_"),                                # all variables whose names start with "sys_"
names_to  = "symptom",                                     # new column that stores symptom name
values_to = "symptom_present"                              # new column that stores Yes/No response
) %>%
dplyr::mutate(
# Give each symptom a short, readable label for plotting
symptom = dplyr::recode(
symptom,
"sys_cough"        = "Cough",
"sys_headache"     = "Headache",
"sys_runny_nose"   = "Runny nose",
"sys_sore_throat"  = "Sore throat",
"sys_chestpain"    = "Chest pain",
"sys_fever"        = "Fever"
),
# Recode Yes/No into 1/0 so we can compute proportions easily
symptom_present = dplyr::if_else(
symptom_present == "Yes",                                # if the original value is "Yes"
1L,                                                      # code as 1 (symptom present)
dplyr::if_else(
symptom_present == "No",                               # if the original value is "No"
0L,                                                    # code as 0 (symptom absent)
NA_integer_                                           # otherwise keep as missing
)
)
)
# 2. Calculate the proportion with each symptom within each study
symptom_summary <- symptom_long %>%
dplyr::filter(!is.na(symptom_present)) %>%                   # drop rows with missing Yes/No
dplyr::group_by(study, symptom) %>%                          # group by study and symptom type
dplyr::summarise(
n          = dplyr::n(),                                   # total number of participants in this group
n_symptom  = sum(symptom_present),                         # count with symptom present (value == 1)
prop_symptom = n_symptom / n                              # proportion with the symptom
) %>%
dplyr::ungroup()                                             # remove grouping to avoid side effects later
# 3. Make a faceted bar plot of symptom proportions by study
p_symptom_study <- ggplot(
symptom_summary,                                             # use summary data frame for plotting
aes(
x = study,                                                 # x-axis: study (HF, pricos, ResViRe)
y = prop_symptom                                           # y-axis: proportion with the symptom
)
) +
geom_col(                                                    # draw solid bars (columns)
fill  = "#1B9E77",                                         # choose a single calm color for all bars
alpha = 0.8                                                # slightly transparent for a softer look
) +
scale_y_continuous(                                          # format y-axis as percentages
labels = scales::percent_format(accuracy = 1)              # show values like 40%
) +
labs(
title   = "Symptom profiles across participating studies", # main title
x       = "Study",                                         # x-axis label
y       = "Participants with symptom",                     # y-axis label
caption = "Each bar shows the proportion of participants within each study reporting the symptom.\nSample sizes are small, so percentages should be interpreted with caution."
) +
facet_wrap(~ symptom, nrow = 2) +                            # create small panels for each symptom
theme_minimal() +                                            # clean, minimal theme
theme(
plot.title = element_text(face = "bold", size = 14),       # emphasize plot title
strip.text = element_text(face = "bold"),                  # bold facet labels (symptom names)
axis.text.x = element_text(angle = 0, hjust = 0.5)         # keep study labels horizontal for readability
)
p_symptom_study                                                 # print the plot to the report
# This chunk visualizes the distribution of participant ages (in years).
# A simple histogram is used due to the small sample size.
ggplot(Data_xfg, aes(x = age_years)) + # map age_years to x-axis
geom_histogram(
bins = 8, # choose a small number of bins
fill = "#2E86AB", # bar color
alpha = 0.8, # slight transparency
color = "white" # white borders for readability
) +
labs(
title = "Age distribution of SARS-CoV-2 positive participants",
x = "Age (years)",
y = "Count"
) +
theme_minimal()
# Expected result: a histogram showing how the 21 participants are distributed across age, highlighting the mix of children, adolescents, and adults.
# This chunk counts, for each participant, how many different symptoms were reported, and then displays the distribution of this count.
# 1. List the symptom variables to be considered.
symptom_vars <- c(
"sys_cough", "sys_headache", "sys_runny_nose",
"sys_sore_throat", "sys_chestpain", "sys_fever"
)
# 2. For each participant, count the number of symptoms with value "Yes".
symptom_counts <- Data_xfg %>%
mutate(
n_symptoms = rowSums(
across(
all_of(symptom_vars),          # apply across the listed symptom variables
~ .x == "Yes"                  # logical test: TRUE if symptom == "Yes"
),
na.rm = TRUE                     # treat NA as 0 when summing
)
)
# 3. Plot the distribution of the count of reported symptoms.
ggplot(symptom_counts, aes(x = n_symptoms)) +
geom_bar(
fill  = "#F39C12",                 # bar color
alpha = 0.8
) +
labs(
title = "Number of reported symptoms per participant",
x     = "Number of symptoms",
y     = "Count"
) +
theme_minimal()
# Expected result: a bar chart showing how many participants reported 0, 1, 2, etc symptoms. This helps describe overall symptom burden in the small cohort.
# This chunk visualizes when samples were collected over time,
# stratified by study and lineage group. Each point is one participant.
timeline_data <- Data_xfg %>%                      # start from the cleaned analysis dataset
dplyr::filter(!is.na(date_collect))              # keep only observations with a valid collection date
ggplot(
timeline_data,
aes(
x     = date_collect,                          # x-axis: sample collection date
y     = study,                                 # y-axis: study (HF, pricos, ResViRe)
color = lineage_group,                         # color: XFG vs Other lineages
shape = clinical_status                        # shape: symptomatic vs asymptomatic
)
) +
geom_jitter(
width  = 0,                                    # no horizontal jitter (date is exact)
height = 0.1,                                  # slight vertical jitter to avoid overplotting
size   = 2.5                                   # point size
) +
scale_x_date(date_labels = "%b %d") +            # show month + day on the x-axis
labs(
title = "Sampling timeline of SARS-CoV-2 infections by study and lineage",
x     = "Sample collection date (2025)",
y     = "Study",
color = "Lineage group",
shape = "Clinical status"
) +
theme_minimal()
# Expected result:
# A dot plot over time showing when each sample was collected in each study,
# with colors distinguishing XFG vs other lineages and shapes showing symptoms.
View(Data_xfg)
# This chunk compares Ct values across 3 studies, with color indicating viral lineage.
# It helps to evaluate whether any study systematically captured infections with higher or lower viral loads, and whether XFG stands out compared with other lineages.
ct_study_data <- Data_xfg %>%                      # start from the cleaned dataset
dplyr::filter(!is.na(ct_value))                  # keep only observations with non-missing Ct values
ggplot(
ct_study_data,
aes(
x     = study,                                 # x-axis: HF, pricos, ResViRe
y     = ct_value,                              # y-axis: Ct value
color = lineage_group                          # color: XFG vs Other lineages
)
) +
geom_boxplot(
alpha        = 0.4,                            # semi-transparent boxes
outlier.shape = NA                             # hide default boxplot outlier points
) +
geom_jitter(
width = 0.1,                                   # slight horizontal jitter
size  = 2                                      # point size
) +
scale_y_reverse() +                              # lower Ct (higher viral load) appears higher on the plot
labs(
title = "Ct values by study and viral lineage",
x     = "Study",
y     = "Ct value (lower = higher viral load)",
color = "Lineage group"
) +
theme_minimal()
# Expected result: Boxplots with overlaid points showing Ct distributions within each study, colored by lineage group, allowing visual comparison of viral load patterns.
# This chunk compares the total number of reported symptoms
# between XFG and non-XFG infections. It summarizes how many
# of the recorded symptoms (cough, headache, runny nose, sore throat,
# chest pain, fever) each participant reported.
# 1. Define symptom variables to be counted.
symptom_vars <- c(
"sys_cough", "sys_headache", "sys_runny_nose",
"sys_sore_throat", "sys_chestpain", "sys_fever"
)
# 2. Create a variable n_symptoms = number of "Yes" responses per participant.
symptom_counts_lineage <- Data_xfg %>%
dplyr::mutate(
n_symptoms = rowSums(
dplyr::across(
dplyr::all_of(symptom_vars),
~ .x == "Yes"                        # logical TRUE if symptom == "Yes"
),
na.rm = TRUE                           # treat missing as 0 in the row sum
)
)
# 3. Plot symptom counts by lineage group.
ggplot(
symptom_counts_lineage,
aes(
x    = lineage_group,                   # x-axis: XFG vs Other lineages
y    = n_symptoms,                      # y-axis: number of symptoms
fill = lineage_group                    # fill color by lineage group
)
) +
geom_boxplot(
alpha        = 0.5,                     # semi-transparent boxes
outlier.shape = NA                      # hide default outlier points
) +
geom_jitter(
width = 0.1,                            # slight jitter to separate overlapping points
size  = 2
) +
scale_y_continuous(
breaks = 0:6                            # possible number of symptoms (0–6)
) +
labs(
title = "Number of reported symptoms by viral lineage",
x     = "Lineage group",
y     = "Number of symptoms"
) +
theme_minimal() +
theme(legend.position = "none")
# Expected result:
# A boxplot with jittered points, comparing how many symptoms were reported
# in XFG versus non-XFG infections.
# This chunk summarizes how many observations were contributed by each study.
# It gives context for later stratified analyses.
study_counts <- Data_xfg %>%                 # start from the cleaned dataset
dplyr::count(study)                        # count number of rows per study
ggplot(
study_counts,
aes(
x = study,                               # x-axis: HF, pricos, ResViRe
y = n                                   # y-axis: number of samples
)
) +
geom_col(
fill  = "#6C5B7B",                      # bar fill color
alpha = 0.85
) +
labs(
title = "Number of samples by study",
x     = "Study",
y     = "Sample size (N)"
) +
theme_minimal()
# Expected result:
# A bar chart showing how many participants were included from each study,
# indicating the relative contribution of HF, pricos, and ResViRe.
# This chunk visualizes the overall distribution of Ct values
# across all sequenced samples in the dataset.
ct_nonmiss <- Data_xfg %>%                   # start from the cleaned dataset
dplyr::filter(!is.na(ct_value))            # keep only records with non-missing Ct values
ggplot(
ct_nonmiss,
aes(x = ct_value)                          # x-axis: Ct value
) +
geom_histogram(
bins  = 8,                               # number of histogram bins
fill  = "#3498DB",                       # bar fill color
alpha = 0.8,
color = "white"                          # bar border color
) +
scale_x_reverse() +                        # reverse x-axis so lower Ct appears on the right
labs(
title = "Distribution of Ct values among sequenced infections",
x     = "Ct value (lower = higher viral load)",
y     = "Count"
) +
theme_minimal()
# Expected result:
# A histogram summarizing Ct values across all 21 samples,
# offering a quick overview of viral load levels before stratified analyses.
# Load raw data and perform initial cleaning
# This chunk reads the raw CSV file, cleans variable names,and creates derived variables needed for later analysis.
library(tidyverse) # data wrangling and visualization
library(lubridate) # date handling
library(janitor) # clean variable names
Data_xfg_raw <- readr::read_csv("data/Data1_xfg.csv")
Data_xfg <- Data_xfg_raw %>%
janitor::clean_names() %>%
mutate(
date_collect = lubridate::dmy(date_collect),
lineage_group = if_else(
stringr::str_starts(nextclade_pango2, "XFG"),
"XFG lineage", "Other lineages"
),
lineage_group = factor(lineage_group),
clinical_status = factor(clinical_status,
levels = c("asymptomatic", "symptomatic")),
study = factor(study,
levels = c("HF", "pricos", "ResViRe"))
)
# Load and prepare analysis dataset
# This chunk reads the raw CSV file, cleans variable names,and creates derived variables used throughout the report.
# 1. Read the raw CSV file from the local "data" folder.
Data_xfg_raw <- readr::read_csv(
file = "data/Data1_xfg.csv"  # relative path to the dataset
)
# 2. Standardize variable names to lower_snake_cas
Data_xfg <- Data_xfg_raw %>%
janitor::clean_names()
# 3. Convert the sample collection date from character (day/month/year) to Date class.
Data_xfg <- Data_xfg %>%
mutate(
date_collect = lubridate::dmy(date_collect)  # dmy() = day-month-year
)
# 4. Create a simplified lineage variable with two levels: "XFG lineage" vs "Other lineages".
Data_xfg <- Data_xfg %>%
mutate(
# nextclade_pango2 是原始的 lineage 变量
lineage_group = if_else(
stringr::str_starts(nextclade_pango2, "XFG"),  # check if lineage begins with "XFG"
"XFG lineage",                                 # label as XFG if TRUE
"Other lineages"                              # label as other lineages otherwise
),
lineage_group = factor(
lineage_group,
levels = c("XFG lineage", "Other lineages")   # set factor level order
)
)
# 5. Encode clinical_status as an ordered factor: asymptomatic (reference) followed by symptomatic.
Data_xfg <- Data_xfg %>%
mutate(
clinical_status = factor(
clinical_status,
levels = c("asymptomatic", "symptomatic")
)
)
# 6. Encode study as a factor with levels ordered to match the original paper.
Data_xfg <- Data_xfg %>%
mutate(
study = factor(
study,
levels = c("HF", "pricos", "ResViRe")  # order studies HF → pricos → ResViRe
)
)
# Load raw data and perform initial cleaning
# This chunk reads the raw CSV file, cleans variable names,
# and creates derived variables needed for later analysis.
library(tidyverse)  # data wrangling and visualization
library(lubridate)  # date handling
library(janitor)    # clean variable names
# Read the dataset from the local data/ folder (relative path)
Data_xfg_raw <- readr::read_csv("data/Data1_xfg.csv")
# Clean variable names and derive factors used later in the report
Data_xfg <- Data_xfg_raw %>%
janitor::clean_names() %>%
mutate(
# Convert collection date from character (day-month-year) to Date
date_collect = lubridate::dmy(date_collect),
# Collapse detailed Pango lineages into a two-level factor:
# XFG vs all other lineages
lineage_group = if_else(
stringr::str_starts(nextclade_pango2, "XFG"),
"XFG lineage",
"Other lineages"
),
lineage_group = factor(lineage_group),
# Make clinical status an ordered factor (asymptomatic -> symptomatic)
clinical_status = factor(
clinical_status,
levels = c("asymptomatic", "symptomatic")
),
# Ensure study labels appear in a consistent order
study = factor(
study,
levels = c("HF", "pricos", "ResViRe")
)
)
# This chunk summarized how many observations were contributed by each study.
# It gave context for later stratified analyses.
study_counts <- Data_xfg %>%
dplyr::count(study) # count number of rows per study
ggplot(study_counts, aes(x = study, y = n)) +
geom_col(
fill = "#6C5B7B",
alpha = 0.85
) +
labs(
title = "Number of samples by study",
x = "Study",
y = "Sample size (N)"
) +
theme_minimal()
# Expected result:A bar chart showing how many participants were included from each study,indicating the relative contribution of HF, pricos, and ResViRe.
# This chunk counts, for each participant, how many different symptoms were reported, and then displays the distribution of this count.
# 1. List the symptom variables to be considered.
symptom_vars <- c(
"sys_cough", "sys_headache", "sys_runny_nose",
"sys_sore_throat", "sys_chestpain", "sys_fever"
)
# 2. For each participant, count the number of symptoms with value "Yes".
symptom_counts <- Data_xfg %>%
mutate(
n_symptoms = rowSums(
across(
all_of(symptom_vars),
~ .x == "Yes" # TRUE when the symptom is present
),
na.rm = TRUE # treat missing as 0 in the sum
)
)
# 3. Plot the distribution of the count of reported symptoms.
ggplot(symptom_counts, aes(x = n_symptoms)) +
geom_bar(
fill = "#F39C12",
alpha = 0.8
) +
labs(
title = "Number of reported symptoms per participant",
x = "Number of symptoms",
y = "Count"
) +
theme_minimal()
# Expected result: a bar chart showing how many participants reported 0, 1, 2, etc symptoms. This helps describe overall symptom burden in the small cohort.
# This chunk visualizes the overall distribution of Ct values across all sequenced samples in the dataset.
ct_nonmiss <- Data_xfg %>%
dplyr::filter(!is.na(ct_value)) # keep only records with observed Ct
ggplot(ct_nonmiss, aes(x = ct_value)) +
geom_histogram(
bins = 8,
fill = "#3498DB",
alpha = 0.8,
color = "white"
) +
scale_x_reverse() + # lower Ct (higher viral load) on the right
labs(
title = "Distribution of Ct values among sequenced infections",
x = "Ct value (lower = higher viral load)",
y = "Count"
) +
theme_minimal()
# Expected result: A histogram summarizing Ct values across all 21 samples, offering a quick overview of viral load levels before stratified analyses.
